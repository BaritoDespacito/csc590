#include "easing.stoy"
#include "sdf.stoy"
#include "transform2d.stoy"

#define PI 3.14159265359
#define PERIOD 1.0

float smin( float a, float b, float k )
{
    k *= 2.0;
    float x = b-a;
    return 0.5*( a+b-sqrt(x*x+k*k) );
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {

<<<<<<< Updated upstream
    /*
    Must be a seamless loop - that is, it should at some point return to a state at which it has already been, and I shouldn't be able to tell where the seam is.
    Must use transformation matrices
    Must include both translational and rotational motion ROTATIONAL DONE TRANSLATINAL WORKING
    Must be meaningfully distinct from the work we've done before YES
    */


=======
>>>>>>> Stashed changes
    vec3 uv = vec3(fragCoord / iResolution.xy, 1.0);
    uv.xy -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

<<<<<<< Updated upstream
    float phase = step(sin(iTime / PERIOD * PI), 0.0);

    // move environment
    uv.x += phase * fract(iTime / PERIOD) * 0.1;

    // create rotating square
    vec3 newUV = vec3(uv.x+0.25, uv.y+0.2, 1.0) * rotateMat(phase * mod(iTime / PERIOD, 1.0) * 0.5 * PI);
    float square1 = rectSdf(vec2(-0.1, 0.0), vec2(0.0, 0.1), newUV.xy);

    // create trees
    float tree1 = rectSdf(vec2(0.4 - mod(iTime / PERIOD, 5.0) * 0.1, -0.2), vec2(0.5 - mod(iTime / PERIOD, 5.0) * 0.1, 0.0), uv.xy);

    // create ground
    float ground = rectSdf(vec2(-1.0, -0.5), vec2(1.0, -0.2), uv.xy);
    // TODO: Add noise to ground
=======
    /*
    Must be a seamless loop
    Must use transformation matrices
    Must include both translational and rotational motion
    Must be meaningfully distinct from the work we've done before DONE
    */

    float phase = floor(mod(iTime / PERIOD, 3.0));

    // rotate paddle
    // vec3 newUV = uv * rotateMat(iTime, vec2(0.0, 0.0));
    vec2 offset = vec2(1.0, 0.0);
    vec3 newUV = uv * translateMat(offset);

    // make paddle
    float circle1 = circleSdfNoStep(vec2(0.0, 0.1), 0.075, newUV.xy);
    float circle2 = circleSdfNoStep(vec2(0.0, 0.1), 0.1, newUV.xy);
    float handle = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.05), 0.015, 0.01, 0.075);
    float handle1 = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.075), 0.0125, 0.02, 0.05);
    float paddle = smin(circle1, handle, 0.04);
    float paddle1 = max(paddle, -handle1);
    float paddle2 = max(paddle1, -circle2);
    float head = max(paddle1, -paddle2);

    vec3 color = step(paddle2, 0.0) * vec3(0.7, 0.54, 0.34)
         + step(handle1, 0.0) * vec3(0.65, 0.49, 0.29)
         + step(head, 0.0) * vec3(0.0, 0.27, 0.46);
>>>>>>> Stashed changes

    vec3 color = square1 * vec3(1.0) + ground * vec3(1.0, 0.78, 0.49) + tree1 * vec3(0.0, 0.5, 0.0);

    fragColor = vec4(color, 1.0); 
}