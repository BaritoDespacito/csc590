#include "easing.stoy"
#include "sdf.stoy"
#include "transform2d.stoy"

#define PI 3.14159265359
#define PERIOD 2.0

float smin( float a, float b, float k )
{
    k *= 2.0;
    float x = b-a;
    return 0.5*( a+b-sqrt(x*x+k*k) );
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {

    /*
    Must be a seamless loop DONE
    Must use transformation matrices DONE
    Must include both translational and rotational motion DONE
    Must be meaningfully distinct from the work we've done before DONE
    Wow factor BALL ANIMATION?
    */

    vec3 uv = vec3(fragCoord / iResolution.xy, 1.0);
    uv.xy -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    // rotate paddle
    vec3 newUV = uv;
    newUV = translateMat(vec2(0.25 * cos(iTime * PI / PERIOD), 0.0)) * newUV;
    newUV *= rotateMat(0.25 * PI * sin(iTime * PI / PERIOD), vec2(0.0, 0.0));

    // make paddle
    float circle1 = circleSdfNoStep(vec2(0.0, 0.1), 0.075, newUV.xy);
    float circle2 = circleSdfNoStep(vec2(0.0, 0.1), 0.1, newUV.xy);
    float handle = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.05), 0.015, 0.01, 0.075);
    float handle1 = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.075), 0.0125, 0.02, 0.05);
    float paddle = smin(circle1, handle, 0.04);
    float paddle1 = max(paddle, -handle1);
    float paddle2 = max(paddle1, -circle2);
    float head = max(paddle1, -paddle2);

    // define repetition
    float columns = 2.0;
    float rows = 2.0;
    vec3 ballUV = uv * vec3(columns, rows, 1.0);

    // make ball move
    ballUV = translateMat(vec2(0.0, (1.0-mod(floor(uv.x), 2.0)) * cos((iTime) * PI / PERIOD) * 0.7)) * ballUV; // right ball
    ballUV = translateMat(vec2(0.0, (mod(floor(uv.x), 2.0)) * cos((iTime + PERIOD) * PI / PERIOD) * 0.7)) * ballUV; // left ball

    // get ball radius
    float radius = 0.045;
    radius -= (1.0 - mod(floor(uv.x), 2.0)) * cos((iTime + PERIOD) * PI / PERIOD) * 0.025; // right ball
    radius -= mod(floor(uv.x), 2.0) * cos((iTime) * PI / PERIOD) * 0.025; // left ball

    // domain repetition
    ballUV.x = fract(ballUV.x);

    // create ball
    float ball = circleSdf(vec2(0.5, -0.5), radius, ballUV.xy);

    // create particle rotation
    vec3 particleUV = vec3(ballUV.x-0.5, ballUV.y+0.5, 1.0);
    particleUV *= rotateMat(PI / 2.0);

    // create particles
    float particle1 = trapezoidSdf(vec2(ballUV.x-0.5, ballUV.y+0.43), 0.01, 0.0, 0.03);
    float particle2 = trapezoidSdf(vec2(particleUV.x, particleUV.y+0.07), 0.0, 0.01, 0.03);
    float particle3 = trapezoidSdf(vec2(particleUV.x, particleUV.y-0.07), 0.01, 0.0, 0.03);
    float particle4 = trapezoidSdf(vec2(ballUV.x-0.5, ballUV.y+0.57), 0.0, 0.01, 0.03);

    // create particle splitter
    float width = 0.1;
    width += (1.0 - mod(floor(uv.x), 2.0)) * step(0.825, sin((iTime - (2.5 / PERIOD)) * PI / PERIOD)) * cos((iTime + PERIOD - (2.5 / PERIOD)) * PI / PERIOD * 5.0) * 0.05; // right ball
    width += mod(floor(uv.x), 2.0) * step(0.825, sin((iTime + PERIOD - (2.5 / PERIOD)) * PI / PERIOD)) * cos((iTime - (2.5 / PERIOD)) * PI / PERIOD * 5.0) * 0.05; // left ball
    float particleSplitter1 = circleSdfNoStep(vec2(0.5, -0.5), 0.02+width, ballUV.xy);
    float particleSplitter2 = circleSdfNoStep(vec2(0.5, -0.5), width, ballUV.xy);
    float particleSplitter = max(particleSplitter1, -particleSplitter2);

    // mix everything
    vec3 color = step(paddle2, 0.0) * vec3(0.7, 0.54, 0.34)
         + step(handle1, 0.0) * vec3(0.65, 0.49, 0.29)
         + step(head, 0.0) * (vec3(0.0, 0.27, 0.46) * mod(floor(uv.x * 2.0), 2.0) + vec3(0.81, 0.0, 0.08) * (1.0 - mod(floor(uv.x * 2.0), 2.0)));
    color = mix(color, vec3(1.0), ball);
    vec3 particles = mix(color, vec3(1.0), max(particle1, max(particle2, max(particle3, particle4))));
    color = mix(color, particles, step(particleSplitter, 0.0));

    fragColor = vec4(color, 1.0); 
}