#include "easing.stoy"
#include "sdf.stoy"
#include "transform2d.stoy"

#define PI 3.14159265359
#define PERIOD 2.0

float smin( float a, float b, float k )
{
    k *= 2.0;
    float x = b-a;
    return 0.5*( a+b-sqrt(x*x+k*k) );
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {

    /*
    Must be a seamless loop
    Must use transformation matrices DONE
    Must include both translational and rotational motion DONE
    Must be meaningfully distinct from the work we've done before DONE
    Wow factor BALL ANIMATION?
    */

    vec3 uv = vec3(fragCoord / iResolution.xy, 1.0);
    uv.xy -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    float phase = floor(mod(iTime / PERIOD, 2.0));

    // rotate paddle
    vec3 newUV = uv;
    newUV = translateMat(vec2(0.25 * cos(iTime * PI / PERIOD), 0.0)) * newUV;
    newUV *= rotateMat(0.25 * PI * sin(iTime * PI / PERIOD), vec2(0.0, 0.0));

    // make paddle
    float circle1 = circleSdfNoStep(vec2(0.0, 0.1), 0.075, newUV.xy);
    float circle2 = circleSdfNoStep(vec2(0.0, 0.1), 0.1, newUV.xy);
    float handle = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.05), 0.015, 0.01, 0.075);
    float handle1 = trapezoidSdfNoStep(vec2(newUV.x-0.0, newUV.y+0.075), 0.0125, 0.02, 0.05);
    float paddle = smin(circle1, handle, 0.04);
    float paddle1 = max(paddle, -handle1);
    float paddle2 = max(paddle1, -circle2);
    float head = max(paddle1, -paddle2);

    // define repetition
    float columns = 2.0;
    float rows = 2.0;
    vec3 ballUV = uv * vec3(columns, rows, 1.0);

    // make ball move
    ballUV.y += (1.0-mod(floor(uv.x), 2.0)) * cos((iTime) * PI / PERIOD) * 0.7; // right ball
    ballUV.y += (mod(floor(uv.x), 2.0)) * cos((iTime + PERIOD) * PI / PERIOD) * 0.7; // left ball

    // get ball radius
    float radius = 0.045;
    radius -= (1.0 - mod(floor(uv.x), 2.0)) * cos((iTime + PERIOD) * PI / PERIOD) * 0.025; // right ball
    radius -= mod(floor(uv.x), 2.0) * cos((iTime) * PI / PERIOD) * 0.025; // left ball

    // domain repetition
    ballUV.x = fract(ballUV.x);

    // create ball
    float ball = circleSdf(vec2(0.5, -0.5), radius, ballUV.xy);

    // mix everything
    vec3 color = step(paddle2, 0.0) * vec3(0.7, 0.54, 0.34)
         + step(handle1, 0.0) * vec3(0.65, 0.49, 0.29)
         + step(head, 0.0) * vec3(0.0, 0.27, 0.46);
    color = mix(color, vec3(1.0), ball);

    fragColor = vec4(color, 1.0); 
}