#define MAX_DIST 32.0
#define MAX_STEPS 64
#define THRESHOLD 0.01
#include "lygia/sdf/sphereSDF.glsl"
#include "lygia/generative/snoise.glsl"
#include "lygia/math/rotate3dX.glsl" 
#define ROWS 15
#define COLS 15
 
struct Light {
    vec3 pos;
    vec3 color;
};
 
vec4 repeatedSpheres(vec3 p, vec3 size, vec3 spacing) {
    vec3 id = round(p/spacing);
 
    float d = 1e20;
    for(int i = -1; i<2; i++) { //
        for(int j = -1; j<2; j++) { //
            for(int k = -1; k<2; k++) {
                vec3 rid = id+vec3(i, j, k);
                rid = clamp(rid,-0.5*(size-1.0), 0.5*(size+1.0));
                vec3 r = p-spacing*rid;
                r.y += 0.5*snoise(0.1*vec3(rid.xz, iTime));
                d = min(d, sphereSDF(r, 0.1));
                // vec3 color = mix(vec3(1.,0.,0.), vec3(0.,0.,1.),d);
                // vec3 c = vec3(d);
                // c *= color;
            }
        }
    }
    float noise = snoise(0.1*vec3(id.xz, iTime));
    // float mixFactor = mix(0.0, 1.0, noise);
    vec3 objectColor = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,1.0), 0.5+0.5*noise);
    // vec3 objectColor = vec3(1.0, 1.0, 0.0);
    return vec4(d, objectColor);
}
 
vec4 scene(vec3 p) {
    // float noise = snoise(p,iTime);
    vec4 d = repeatedSpheres(p, vec3(ROWS, 0, COLS), vec3(0.25, 0.0, 0.25));
    return d;
}
 
vec3 calcNormal(vec3 p) {
    const float h = 0.00001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize(k.xyy*scene(p+k.xyy*h).x+k.yyx*scene(p+k.yyx*h).x+k.yxy*scene(p+k.yxy*h).x+k.xxx*scene(p+k.xxx*h).x);
}
 
float shadows(vec3 rayOrigin, vec3 light) {
    float d = 100.0*THRESHOLD;
    vec3 rayHeading = normalize(light-rayOrigin);
    float val = 1.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        vec4 sd = scene(p);
        if(sd.x<THRESHOLD) {
            return 0.0;
        }
        val = min(val, 8.0*sd.x/d);
        float distToLight = length(light-p);
        if(distToLight<THRESHOLD) {
            return val;
        }
        d += min(sd.x, distToLight);
        if(d>MAX_DIST) {
            break;
        }
    }
    return 1.0;
}
 
vec3 lighting(vec3 p) {
    Light lights[1] = Light[1]( //
    Light(vec3(-10., 8., 5.), vec3(1.0)) //
    );
 
    vec3 color = vec3(0.0);
    vec3 norm = calcNormal(p);
    for(int i = 0; i<lights.length(); i++) {
        vec3 toLight = normalize(lights[i].pos-p);
        color += shadows(p, lights[i].pos)* //
            clamp(dot(toLight, norm), 0., 1.)* //
            lights[i].color;
    }
    return color;
}
 
vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        vec4 sd = scene(p);
        vec3 objectColor = sd.yzw;
        if(sd.x<THRESHOLD) {
            return (objectColor*lighting(p));
        }
        d += sd.x;
        if(d>MAX_DIST) {
            break;
        }
    }
    return vec3(0.0);
}
 
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x/iResolution.y;
 
    vec3 rd = normalize(vec3(uv,-1.0));
    rd = rotate3dX(-0.5)*rd; // rotate the camera down
    vec3 ro = vec3(0.0, 3.0, 5.0);
 
    vec3 color = rayMarch(ro, rd);
 
    fragColor = vec4(color, 1.0);
}