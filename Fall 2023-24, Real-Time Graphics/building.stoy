#include "sdf.stoy"
#define PI 3.14159265359

float smin( float a, float b, float k )
{
    k *= 2.0;
    float x = b-a;
    return 0.5*( a+b-sqrt(x*x+k*k) );
}

float clockArm(vec2 uv, float theta) {

    mat2 rotate = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));
    uv *= rotate;

    float arm1 = rectSdf(vec2(-0.0025, 0.0), vec2(0.0025, 0.075), uv);
    float hand1 = equiTriangleSdf(vec2(uv.x-0.0, uv.y-0.075), 0.01);
    float arm = max(arm1, hand1);
    return arm;
}

float clock(vec2 uv) {

    vec2 newUV = uv - vec2(0.0, 0.35);

    float theta = 1.0*PI/2.0*iTime;
    mat2 rotate = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));
    // newUV *= rotate;

    float theta2 = 1.0*PI/2.0;
    mat2 rotate2 = mat2(cos(theta2), -sin(theta2), sin(theta2), cos(theta2));
    vec2 hand2uv = (newUV - vec2(0.075, 0.0))*rotate2;

    // making clock hands
    float hinge = circleSdf(vec2(0.0, 0.0), 0.005, newUV);
    float arm1 = clockArm(newUV, 2.0*PI*iTime/60.0);
    float arm2 = clockArm(newUV, 2.0*PI*iTime/3600.0);
    float arm3 = clockArm(newUV, 2.0*PI*iTime/43200.0);

    float clock = max(hinge, max(arm1, max(arm2, arm3)));

    return clock;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    
    /*
    At least 4 different SDFs DONE
    At least 1 use of a smooth minimum function DONE
    Color, including one non-solid color WHAT IS A NON SOLID COLOR?
    At least 1 animated element DONE
    */

    vec2 uv = fragCoord / iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    // making the background
    vec3 backgroundSky = vec3(0.0, 0.3, 0.7);
    vec3 backgroundGround = vec3(0.0, 0.5, 0.0);
    vec3 background = mix(backgroundSky, backgroundGround, circleSdf(vec2(0.0, -1.0), 0.75, uv));

    // making clouds
    float cloud1a = cutDiskSdf(vec2(uv.x-0.27, uv.y-0.29+0.01*cos(iTime)), 0.1, 0.1*0.2);
    float cloud1b = cutDiskSdf(vec2(uv.x-0.17, uv.y-0.29+0.01*cos(iTime)), 0.12, 0.1*0.2);
    float cloud1c = cutDiskSdf(vec2(uv.x-0.23, uv.y-0.34+0.01*cos(iTime)), 0.1, 0.1*0.2);
    float cloud1 = max(cloud1a, max(cloud1b, cloud1c));
    float cloud2a = cutDiskSdf(vec2(uv.x+0.27, uv.y-0.22+0.01*cos(iTime)), 0.1, 0.1*0.2);
    float cloud2b = cutDiskSdf(vec2(uv.x+0.17, uv.y-0.22+0.01*cos(iTime)), 0.12, 0.1*0.2);
    float cloud2c = cutDiskSdf(vec2(uv.x+0.23, uv.y-0.27+0.01*cos(iTime)), 0.1, 0.1*0.2);
    float cloud2 = max(cloud2a, max(cloud2b, cloud2c));
    vec3 backgroundWithClouds = mix(background, vec3(0.9, 0.9, 0.9), max(cloud1, cloud2));

    // making the building
    float body = rectSdfNoStep(vec2(-0.1, -0.4), vec2(0.1, 0.35), uv);
    float top = circleSdfNoStep(vec2(0.0, 0.375), 0.1, uv);
    float building = smin(body, top, 0.05);
    float buildingWithTop = step(building, 0.0);

    // making clock face
    float clockFace = circleSdf(vec2(0.0, 0.35), 0.1, uv);

    // making windows
    float buildingWithWindows;
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 15; j++) {
            float window = rectSdf(vec2(-0.09 + 0.04*float(i), -0.36 + 0.04*float(j)), vec2(-0.07 + 0.04*float(i), -0.34 + 0.04*float(j)), uv);
            buildingWithWindows += window;
        }
    }
    // adding a door
    buildingWithWindows += rectSdf(vec2(-0.01, -0.404), vec2(0.01, -0.37), uv);

    // mixing the background and the building
    vec3 finalBuilding = mix(backgroundWithClouds, vec3(0.5, 0.4, 0.5), buildingWithTop);
    // adding windows
    finalBuilding = mix(finalBuilding, vec3(0.2, 0.1, 0.2), buildingWithWindows);
    // adding clock
    finalBuilding = mix(finalBuilding, vec3(0.75, 0.75, 0.75), clockFace);
    // adding clock hands
    finalBuilding = mix(finalBuilding, vec3(0.0, 0.0, 0.0), clock(uv));
    
    // vec3 color = vec3(buildingWithTop);
    fragColor = vec4(finalBuilding, 1.0);

}