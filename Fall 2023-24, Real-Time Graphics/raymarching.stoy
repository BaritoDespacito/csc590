#include "sdf.stoy"

#define MAX_DIST 5.0
#define MIN_DIST 0.00001
#define MAX_STEPS 2000

float scene(vec3 p) {
    float sphere1 = sphereSdf(p, 0.25, vec3(-0.1, 0.0, 2.0));
    float sphere2 = sphereSdf(p, 0.25, vec3(0.1, 0.0, 3.0));
    return min(sphere1, sphere2);
}

vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.0; // sdf distance to the sphere from eyeball
    for (int i = 0; i < MAX_STEPS; i++) { // repeat until max steps
        vec3 p = rayOrigin + d * rayHeading; // move p to a new point on the closest point
        float dist = scene(p); // get the distance to the closest point from p
        if (dist < MIN_DIST) {
            return vec3(1.0-(d)*0.1); // if the distance is close enough, return white
        }
        d += dist; // add the distance to the min distance, then repeat to move p
        if (d > MAX_DIST) { // if min distance is greater than limit break
            break;
        }
    }
    return vec3(0.0, 0.0, 0.0); // if no points are close enough, return black
}


void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    vec3 camera = vec3(0.0, 0.0, -1.0);
    vec3 col = rayMarch(vec3(uv, 0.0), normalize(vec3(uv, 1.0) - camera));

    fragColor = vec4(col, 1.0);
}