#include "sdf.stoy"

#define MAX_DIST 5.0
#define MIN_DIST 0.00001
#define MAX_STEPS 2000

float scene(vec3 p) {
    float sphere1 = sphereSdf(p, 0.25, vec3(-0.2, 0.0, 2.0));
    float sphere2 = sphereSdf(p, 0.2, vec3(0.1, -0.1, 3.0));
    float plane = planeSdf(p, normalize(vec3(0.0, 1.0, -0.1)), 1.0);
    return min(sphere1, min(sphere2, plane));
}

vec3 calcNormal( in vec3 p ) // for function f(p)
{
    const float h = 0.0001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*scene( p + k.xyy*h ) + 
                      k.yyx*scene( p + k.yyx*h ) + 
                      k.yxy*scene( p + k.yxy*h ) + 
                      k.xxx*scene( p + k.xxx*h ) );
}

float rayMarchShadow(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.1; // sdf distance to the sphere from eyeball
    for (int i = 0; i < MAX_STEPS; i++) { // repeat until max steps
        vec3 p = rayOrigin + d * rayHeading; // move p to a new point on the closest point
        float dist = scene(p); // get the distance to the closest point from p
        if (dist < MIN_DIST) {
            return 0.0; // if the distance is close enough, return 0.0 to make black
        }
        d += dist; // add the distance to the min distance, then repeat to move p
        if (d > MAX_DIST) { // if min distance is greater than limit break
            break;
        }
    }
    return 1.0; // if no points are close enough, return 1.0 to keep light the same
}

vec3 lighting(vec3 p, vec3 col, vec3 source) {
    // vec3 source = vec3(-1.0 + 2.0 * sin(iTime), 1.0 + 1.0 * sin(iTime), 1.0 + sin(iTime)); // define source
    vec3 lightDirection = normalize(source - p); // vector from point to light source
    vec3 normal = calcNormal(p); // surface normal at point
    float diff = dot(normal, lightDirection); // dot product to find light, clamp to 0
    return diff * col * rayMarchShadow(p, lightDirection); // return the light value
}

vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading, vec3 col, vec3 source) {
    float d = 0.0; // sdf distance to the sphere from eyeball
    for (int i = 0; i < MAX_STEPS; i++) { // repeat until max steps
        vec3 p = rayOrigin + d * rayHeading; // move p to a new point on the closest point
        float dist = scene(p); // get the distance to the closest point from p
        if (dist < MIN_DIST) {
            return lighting(p, col, source);
        }
        d += dist; // add the distance to the min distance, then repeat to move p
        if (d > MAX_DIST) { // if min distance is greater than limit break
            break;
        }
    }
    return vec3(0.0, 0.0, 0.0); // if no points are close enough, return black
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    vec3 camera = vec3(0.0, 0.0, -1.0);
    vec3 lightRed = rayMarch(camera, normalize(vec3(uv, 1.0) - camera), vec3(1.0, 0.0, 0.0), vec3(-1.0 + 2.0 * sin(iTime), 1.0 + 1.0 * sin(iTime), 1.0 + sin(iTime)));
    vec3 lightBlue = rayMarch(camera, normalize(vec3(uv, 1.0) - camera), vec3(0.0, 0.0, 1.0), vec3(1.0 + 2.0 * sin(iTime), 1.0 + 1.0 * sin(iTime), 1.0 + sin(iTime)));

    vec3 color = lightRed + lightBlue;

    fragColor = vec4(color, 1.0);
}