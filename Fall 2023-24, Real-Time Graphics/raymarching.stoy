#include "sdf.stoy"

#define MAX_DIST 10.0
#define MIN_DIST 0.0001
#define MAX_STEPS 2000

struct Light {
    vec3 color;
    vec3 source;
};

float scene(vec3 p) {
    float sphere1 = sphereSdf(p, 0.25, vec3(-0.2, 0.0, 2.0));
    float sphere2 = sphereSdf(p, 0.2, vec3(0.1, -0.1, 3.0));
    float plane = planeSdf(p, normalize(vec3(0.0, 1.0, -0.1)), 1.0);
    return min(sphere1, min(sphere2, plane));
}

vec3 calcNormal( in vec3 p ) // for function f(p)
{
    const float h = 0.0001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*scene( p + k.xyy*h ) + 
                      k.yyx*scene( p + k.yyx*h ) + 
                      k.yxy*scene( p + k.yxy*h ) + 
                      k.xxx*scene( p + k.xxx*h ) );
}

float rayMarchShadow(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.1; // sdf distance to the sphere from eyeball
    float light = 1.0; // light value
    for (int i = 0; i < MAX_STEPS; i++) { // repeat until max steps
        vec3 p = rayOrigin + d * rayHeading; // move p to a new point on the closest point
        float dist = scene(p); // get the distance to the closest point from p
        light = min(light, 32.0 * dist / d); // calculate the light value
        if (dist < MIN_DIST) {
            return 0.0;
            // return light; // if the distance is close enough, return 0.0 to make black
        }
        float distToLight = length(p-rayOrigin); // distance to the light source
        d += min(dist, distToLight); // add the distance to the min distance, then repeat to move p
        if (d > MAX_DIST) { // if min distance is greater than limit break
            break;
        }
    }
    // return 1.0;
    return light; // if no points are close enough, return 1.0 to keep light the same
}

vec3 lighting(vec3 p, vec3 col, vec3 source) {
    // vec3 source = vec3(-1.0 + 2.0 * sin(iTime), 1.0 + 1.0 * sin(iTime), 1.0 + sin(iTime)); // define source
    vec3 lightDirection = normalize(source - p); // vector from point to light source
    vec3 normal = calcNormal(p); // surface normal at point
    float diff = dot(normal, lightDirection); // dot product to find light, clamp to 0
    return diff * col * rayMarchShadow(p, lightDirection); // return the light value
}

vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading, vec3 col, vec3 source) {
    float d = 0.0; // sdf distance to the sphere from eyeball
    for (int i = 0; i < MAX_STEPS; i++) { // repeat until max steps
        vec3 p = rayOrigin + d * rayHeading; // move p to a new point on the closest point
        float dist = scene(p); // get the distance to the closest point from p
        if (dist < MIN_DIST) {
            return lighting(p, col, source);
        }
        d += dist; // add the distance to the min distance, then repeat to move p
        if (d > MAX_DIST) { // if min distance is greater than limit break
            break;
        }
    }
    return vec3(0.0, 0.0, 0.0); // if no points are close enough, return black
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x / iResolution.y;

    vec3 camera = vec3(0.0, 0.0, -2.0);
    // camera += vec3(2.0*cos(iTime), 0.0, 2.0+2.0*sin(iTime));
    
    Light[] lights = Light[](
        Light(vec3(1.0, 0.0, 0.0), vec3(-1.0, 1.0, 0.0)),
        Light(vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0))
    );

    lights[0].source += vec3(2.0*cos(iTime), 0.0, 2.0*sin(iTime));

    vec3 color = vec3(0.0);
    for (int i = 0; i < lights.length(); i++) {
        Light light = lights[i];
        vec3 rayHeading = normalize(vec3(uv, 1.0));
        color += rayMarch(camera, rayHeading, light.color, light.source);
    }

    fragColor = vec4(color, 1.0);
}