#define MAX_DIST 64.0
#define MAX_STEPS 64
#define THRESHOLD 0.01
#include "lygia/sdf/sphereSDF.glsl"
#include "lygia/sdf/boxSDF.glsl"
#include "lygia/sdf/pyramidSDF.glsl"
#include "lygia/generative/snoise.glsl"
#include "lygia/math/rotate3dX.glsl" 
#include "lygia/math/rotate3dY.glsl"
#include "lygia/math/rotate3dZ.glsl"
#include "lygia/sdf/opUnion.glsl"
#define ROWS 15
#define COLS 15
 
struct Light {
    vec3 pos;
    vec3 color;
};

struct Surface {
    float sd; // signed distance value
    vec3 col; // color
};

Surface boxSDF(vec3 p, vec3 size, vec3 color) {
    return Surface(boxSDF(p, size), color);
}

Surface pyramidSDF(vec3 p, float size, vec3 color) {
    return Surface(pyramidSDF(p, size), color);
}

Surface minWithColor(Surface obj1, Surface obj2) {
  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the "signed distance" value
  return obj1;
}

Surface maxWithColor(Surface obj1, Surface obj2) {
  if (obj2.sd > obj1.sd) return obj2;
  return obj1;
}

Surface scene(vec3 p) {
    Surface base = boxSDF(p, vec3(1.0, 8.0, 1.0), vec3(0.92, 0.71, 0.46));
    Surface pyramid1 = pyramidSDF(vec3(p.x/2.0, p.y-8.0, p.z/2.0), 10.0, vec3(0.08, 0.30, 0.30));
    Surface attic = boxSDF(vec3(p.x, p.y-11.0, p.z), vec3(0.8, 0.7, 0.8), vec3(0.92, 0.71, 0.46));
    Surface pyramid2 = pyramidSDF(vec3(p.x/1.25, p.y-11.8, p.z/1.25), 1.0, vec3(0.08, 0.30, 0.30));

    Surface slant1 = maxWithColor(pyramid1, attic);

    return minWithColor(base, minWithColor(pyramid1, minWithColor(attic, pyramid2)));
}
 
vec3 calcNormal(vec3 p) {
    const float h = 0.00001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize(k.xyy*scene(p+k.xyy*h).sd+k.yyx*scene(p+k.yyx*h).sd+k.yxy*scene(p+k.yxy*h).sd+k.xxx*scene(p+k.xxx*h).sd);
}
 
float shadows(vec3 rayOrigin, vec3 light) {
    float d = 100.0*THRESHOLD;
    vec3 rayHeading = normalize(light-rayOrigin);
    float val = 1.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        Surface sd = scene(p);
        if(sd.sd<THRESHOLD) {
            return 0.0;
        }
        val = min(val, 8.0*sd.sd/d);
        float distToLight = length(light-p);
        if(distToLight<THRESHOLD) {
            return val;
        }
        d += min(sd.sd, distToLight);
        if(d>MAX_DIST) {
            break;
        }
    }
    return 1.0;
}
 
vec3 lighting(vec3 p) {
    Light lights[1] = Light[1]( //
    Light(vec3(-10., 8., 5.), vec3(1.0)) //
    );
 
    vec3 color = vec3(0.0);
    vec3 norm = calcNormal(p);
    for(int i = 0; i<lights.length(); i++) {
        vec3 toLight = normalize(lights[i].pos-p);
        color += shadows(p, lights[i].pos)* //
            clamp(dot(toLight, norm), 0., 1.)* //
            lights[i].color;
    }
    return color;
}
 
vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        Surface sd = scene(p);
        vec3 objectColor = sd.col;
        if(sd.sd<THRESHOLD) {
            return (objectColor*lighting(p));
        }
        d += sd.sd;
        if(d>MAX_DIST) {
            break;
        }
    }
    return vec3(0.0);
}
 
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x/iResolution.y;
 
    vec3 rd = normalize(vec3(uv,-1.0));
    // rd = rotate3dX(0.375)*rd; // rotate the camera up
    // rd = rotate3dY(-0.25)*rd; // rotate the camera right
    // vec3 ro = vec3(-7.0, -7.0, 25.0);
    vec3 ro = vec3(0.0, 3.0, 25.0);
 
    vec3 color = rayMarch(ro, rd);
 
    fragColor = vec4(color, 1.0);
}