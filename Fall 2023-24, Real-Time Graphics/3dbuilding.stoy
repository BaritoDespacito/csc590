#define MAX_DIST 64.0
#define MAX_STEPS 64
#define THRESHOLD 0.01
#include "lygia/sdf/sphereSDF.glsl"
#include "lygia/sdf/boxSDF.glsl"
#include "lygia/sdf/pyramidSDF.glsl"
#include "lygia/generative/snoise.glsl"
#include "lygia/math/rotate3dX.glsl" 
#include "lygia/math/rotate3dY.glsl"
#define ROWS 15
#define COLS 15
 
struct Light {
    vec3 pos;
    vec3 color;
};
 
vec4 scene(vec3 p) {
    vec4 base = vec4(boxSDF(p, vec3(1.0, 8.0, 1.0)), vec3(0.92, 0.71, 0.46));
    vec4 pyramid1 = vec4(pyramidSDF(vec3(p.x/2.0, p.y-8.0, p.z/2.0), 10.0), vec3(0.08, 0.30, 0.47));
    vec4 attic = vec4(boxSDF(vec3(p.x, p.y-10.0, p.z), vec3(1.0, 1.0, 1.0)), vec3(0.92, 0.71, 0.46));
    return (min(base, min(pyramid1, attic)));
}
 
vec3 calcNormal(vec3 p) {
    const float h = 0.00001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize(k.xyy*scene(p+k.xyy*h).x+k.yyx*scene(p+k.yyx*h).x+k.yxy*scene(p+k.yxy*h).x+k.xxx*scene(p+k.xxx*h).x);
}
 
float shadows(vec3 rayOrigin, vec3 light) {
    float d = 100.0*THRESHOLD;
    vec3 rayHeading = normalize(light-rayOrigin);
    float val = 1.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        vec4 sd = scene(p);
        if(sd.x<THRESHOLD) {
            return 0.0;
        }
        val = min(val, 8.0*sd.x/d);
        float distToLight = length(light-p);
        if(distToLight<THRESHOLD) {
            return val;
        }
        d += min(sd.x, distToLight);
        if(d>MAX_DIST) {
            break;
        }
    }
    return 1.0;
}
 
vec3 lighting(vec3 p) {
    Light lights[1] = Light[1]( //
    Light(vec3(-10., 8., 5.), vec3(1.0)) //
    );
 
    vec3 color = vec3(0.0);
    vec3 norm = calcNormal(p);
    for(int i = 0; i<lights.length(); i++) {
        vec3 toLight = normalize(lights[i].pos-p);
        color += shadows(p, lights[i].pos)* //
            clamp(dot(toLight, norm), 0., 1.)* //
            lights[i].color;
    }
    return color;
}
 
vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        vec4 sd = scene(p);
        vec3 objectColor = sd.yzw;
        if(sd.x<THRESHOLD) {
            return (objectColor*lighting(p));
        }
        d += sd.x;
        if(d>MAX_DIST) {
            break;
        }
    }
    return vec3(0.0);
}
 
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x/iResolution.y;
 
    vec3 rd = normalize(vec3(uv,-1.0));
    // rd = rotate3dX(0.375)*rd; // rotate the camera up
    // rd = rotate3dY(-0.25)*rd; // rotate the camera right
    // vec3 ro = vec3(-7.0, -7.0, 25.0);
    vec3 ro = vec3(0.0, 3.0, 25.0);
 
    vec3 color = rayMarch(ro, rd);
 
    fragColor = vec4(color, 1.0);
}