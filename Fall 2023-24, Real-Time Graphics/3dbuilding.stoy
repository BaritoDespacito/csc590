#define MAX_DIST 128.0
#define MAX_STEPS 128
#define THRESHOLD 0.01

#include "lygia/sdf/sphereSDF.glsl"
#include "lygia/sdf/boxSDF.glsl"
#include "lygia/sdf/pyramidSDF.glsl"
#include "lygia/sdf/cylinderSDF.glsl"

#include "lygia/generative/snoise.glsl"

#include "lygia/math/rotate3dX.glsl" 
#include "lygia/math/rotate3dY.glsl"
#include "lygia/math/rotate3dZ.glsl"
#include "lygia/math/rotate4dZ.glsl"
#include "lygia/math/translate4d.glsl"
#include "lygia/math/toMat3.glsl"

#include "lygia/sdf/opUnion.glsl"
#include "lygia/sdf/opSubtraction.glsl"

#define ROWS 15
#define COLS 15
#define PI 3.14159265359
 
struct Light {
    vec3 pos;
    vec3 color;
};

struct Surface {
    float sd; // signed distance value
    vec3 col; // color
};

Surface boxSDF(vec3 p, vec3 size, vec3 color) {
    return Surface(boxSDF(p, size), color);
}

Surface pyramidSDF(vec3 p, float size, vec3 color) {
    return Surface(pyramidSDF(p, size), color);
}

Surface cylinderSDF(vec3 p, vec3 a, vec3 b, float r, vec3 color) {
    return Surface(cylinderSDF(p, a, b, r), color);
}

Surface handSDF(vec3 p, vec3 size, float theta, vec3 color) {

    vec4 newP = vec4(p, 1.0);
    newP = translate4d(vec3(0.0, -size.y, 0.0))*newP;
    newP *= rotate4dZ(theta);
    newP = translate4d(vec3(0.0, -size.y, 0.0))*newP;
    float box = boxSDF(newP.xyz, size);
    return Surface(box, color);
}

float smin( float a, float b, float k ) {
    k *= 2.0;
    float x = b-a;
    return 0.5*( a+b-sqrt(x*x+k*k) );
}

Surface minWithColor(Surface obj1, Surface obj2) {
  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the "signed distance" value
  return obj1;
}

Surface maxWithColor(Surface obj1, Surface obj2) {
  if (max(-obj1.sd, obj2.sd) == obj2.sd) return obj2;
  return obj1;
}

Surface clock(vec3 p) {
    float baseNoColor = boxSDF(p, vec3(1.0, 8.0, 1.0));

    float clockFace = boxSDF(vec3(p.x, p.y-6.5, p.z), vec3(1.1, 1.1, 1.1));
    Surface clockFaceSmooth = Surface(smin(clockFace, baseNoColor, 0.15), vec3(0.92, 0.71, 0.46));
    Surface clockBackground = cylinderSDF(p, vec3(0.0, 6.5, 1.28), vec3(0.0, 6.5, -1.28), 0.9, vec3(1.0));
    Surface clockFaceBackground = minWithColor(clockFaceSmooth, clockBackground);

    Surface hourHand = handSDF(vec3(p.x, p.y-6.3, p.z-1.28), vec3(0.03, 0.2, 0.03), -2.0*PI*iTime/43200.0, vec3(0.08, 0.15, 0.2));
    Surface minuteHand = handSDF(vec3(p.x, p.y-6.1, p.z-1.28), vec3(0.03, 0.4, 0.03), -2.0*PI*iTime/3600.0, vec3(0.08, 0.15, 0.2));
    Surface clockHands = minWithColor(hourHand, minuteHand);

    Surface clockFaceWithHands = minWithColor(clockFaceBackground, clockHands);

    return clockFaceWithHands;
}

Surface scene(vec3 p) {

    // create main structure
    float baseNoColor = boxSDF(p, vec3(1.0, 8.0, 1.0));
    Surface base = Surface(baseNoColor, vec3(0.92, 0.71, 0.46));

    float pyramid1 = pyramidSDF(vec3(p.x/2.0, p.y-8.0, p.z/2.0), 10.0);
    float pyramidSubtractor1 = boxSDF(vec3(p.x, p.y-11.0, p.z), vec3(0.8, 7.0, 0.8));
    Surface slant1 = Surface(opSubtraction(pyramidSubtractor1, pyramid1), vec3(0.08, 0.15, 0.2));

    Surface attic = boxSDF(vec3(p.x, p.y-11.0, p.z), vec3(0.8, 0.7, 0.8), vec3(0.92, 0.71, 0.46));

    float pyramid2 = pyramidSDF(vec3(p.x/2.0, p.y-9.21, p.z/2.0), 10.0);
    float pyramidSubtractor2 = boxSDF(vec3(p.x, p.y-9.21, p.z), vec3(1.5, 2.21, 1.5));
    Surface slant2 = Surface(opSubtraction(pyramidSubtractor2, pyramid2), vec3(0.08, 0.15, 0.2));

    Surface mainStructure = minWithColor(base, minWithColor(slant1, minWithColor(attic, slant2)));

    // create clock face
    Surface clock = clock(p);

    // return clockHands;
    return minWithColor(mainStructure, clock);
}
 
vec3 calcNormal(vec3 p) {
    const float h = 0.00001; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    return normalize(k.xyy*scene(p+k.xyy*h).sd+k.yyx*scene(p+k.yyx*h).sd+k.yxy*scene(p+k.yxy*h).sd+k.xxx*scene(p+k.xxx*h).sd);
}
 
float shadows(vec3 rayOrigin, vec3 light) {
    float d = 100.0*THRESHOLD;
    vec3 rayHeading = normalize(light-rayOrigin);
    float val = 1.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        Surface sd = scene(p);
        if(sd.sd<THRESHOLD) {
            return 0.0;
        }
        val = min(val, 8.0*sd.sd/d);
        float distToLight = length(light-p);
        if(distToLight<THRESHOLD) {
            return val;
        }
        d += min(sd.sd, distToLight);
        if(d>MAX_DIST) {
            break;
        }
    }
    return 1.0;
}
 
vec3 lighting(vec3 p) {
    Light lights[1] = Light[1]( //
    Light(vec3(-10., 8., 5.), vec3(1.0)) //
    );
 
    vec3 color = vec3(0.0);
    vec3 norm = calcNormal(p);
    for(int i = 0; i<lights.length(); i++) {
        vec3 toLight = normalize(lights[i].pos-p);
        color += shadows(p, lights[i].pos)* //
            clamp(dot(toLight, norm), 0., 1.)* //
            lights[i].color;
    }
    return color;
}
 
vec3 rayMarch(vec3 rayOrigin, vec3 rayHeading) {
    float d = 0.0;
    for(int i = 0; i<MAX_STEPS; i++) {
        vec3 p = rayOrigin+d*rayHeading;
        Surface sd = scene(p);
        vec3 objectColor = sd.col;
        if(sd.sd<THRESHOLD) {
            return (objectColor*lighting(p));
        }
        d += sd.sd;
        if(d>MAX_DIST) {
            break;
        }
    }
    return vec3(0.04, 0.41, 0.62);
}
 
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    uv -= 0.5;
    uv.x *= iResolution.x/iResolution.y;
 
    vec3 rd = normalize(vec3(uv,-1.0));
    vec3 ro = vec3(1.0);

    // ground view camera
    rd = rotate3dX(0.375)*rd; // rotate the camera up
    rd = rotate3dY(-0.25)*rd; // rotate the camera right
    ro = vec3(-7.0, -7.0, 25.0);

    // side camera
    // rd = rotate3dY(-PI/2.0)*rd;
    // ro = vec3(-10.0, 5.0, 1.0);

    // front camera
    // ro = vec3(0.0, 5.0, 10.0);
 
    vec3 color = rayMarch(ro, rd);
 
    fragColor = vec4(color, 1.0);
}